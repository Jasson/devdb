该模块主要是网络相关的一些helper方法

1. APIs:
   http_get(Url :: string(), Timeout :: pos_integer()) ->
      {ok, Result} | {error, Reason}
   http_get(Url :: string(), Timeout :: pos_integer(), Sync :: bool()) ->
      {ok, Result} | {error, Reason}

   Result = {status_line(), headers(), body()} | {status_code(), body()} | request_id() 
   status_line()   = {http_version(), status_code(), reason_phrase()}
   http_version()  = string() ex: "HTTP/1.1"
   status_code()   = integer()
   reason_phrase() = string()
   body()          = binary()

   Timeout的单位是millisecond, 也可以是infinity.

   发送一个HTTP GET请求, 包含一个{"connection", "close"}头选项, 这个请求可以是同步的, 也可以是异步的:
   a. 如果是同步的, 直接返回结果
   b. 如果是异步的, 返回一个request_id(), 我们可以根据这个id在发起请求的process中接收数据.
      数据的格式是: 
      {http, {Ref, {error, Reason}}}或者{http, {Ref, Data}}

2. 例子, 展示了同步和异步HTTP GET请求的处理方式:
module(http_request).
-export([sync/1, async/1,
	 test_http_request/0]).

-define(PRINT(Msg), io:format("print#~p~n", [Msg])).
-define(ERROR(Msg), io:format("error#~p~n", [Msg])).

sync(Url) ->
    Options = [{sync, true}, {body_format, binary}],
    HttpOptions = [{timeout, infinity}, {autoredirect, true}],
    case http:request(get, {Url, [{"connection", "close"}]}, HttpOptions, Options) of
        {ok, Result} ->
            ?PRINT(Result);
        {error, Reason} ->
            ?ERROR(Reason)
    end.

async(Url) ->
    Options = [{sync, false}, {body_format, binary}],
    HttpOptions = [{timeout, infinity}, {autoredirect, true}],
    case http:request(get, {Url, [{"connection", "close"}]}, HttpOptions, Options) of
        {ok, Ref} ->
            recv(Ref);
        {error, Reason} ->
            ?ERROR(Reason)
    end.

%% Internal APIs:
recv(Ref) ->
    receive 
	{http, {Ref, {error, Reason}}} -> ?ERROR(Reason);
	{http, {Ref, Data}} -> ?PRINT(Data)
    end.

test_http_request() ->
    Url = "http://www.google.com",
    async(Url),
    sync(Url).
