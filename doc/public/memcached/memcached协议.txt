               Memcached协议(仅供参考)

主要内容:
a. 协议
b. 关键字 Key
c. 命令 Command
d. 过期时间 Expiration Time
e. 错误字串 Error String
f. 存储命令 Storage Command
g. 读取命令 Retrieval Command
h. 删除命令 Delete Command
i. 增加/减少 Increment/Decrement
j. 统计 Statistics
k. 多种统计 General Purpose Statistics
l. 其它命令 Other Command


1. 协议
memcached的客户端使用TCP链接与服务器通讯(UDP接口也同样有效, 参考后文的 “UDP协议”).
一个运行中的memcached服务器监视一些(可设置)端口, 客户端连接这些端口, 发送命令到服务器, 
读取回应, 最后关闭连接.

结束会话不需要发送任何命令, 当不再需memcached服务时, 客户端可以在任何时候关闭连接.
需要注意的是, 鼓励客户端缓存这些连接, 而不是每次需要存取数据时都重新打开连接. 这是因为memcached 
被特意设计成及时开启很多连接也能够高效的工作(数百个, 上千个如果需要的话). 缓存这些连接, 可以消除建立
连接所带来的开销(相对而言, 在服务器端建立一个新连接的准备工作所带来的开销, 可以忽略不计).

在memcache协议中发送的数据分两种: 文本行和自由数据.
文本行被用于来自客户端的命令和服务器的回应, 自由数据用于客户端从服务器端存取数据时, 同样服务器会以字节流的
方式传回自由数据. 服务器不用关心自由数据的字节顺序, 自由数据的特征没有任何限制, 但是通过前文提到的文本行,
这项数据的接受者(服务器或客户端)便能够精确地获知所发送的数据库的长度.

文本行固定以“\r\n”(回车符紧跟一个换行符)结束. 自由数据也是同样会以“\r\n”结束, 但是 \r(回车符), \n(换行符)
以及任何其他8位字符, 均可出现在数据中. 因此, 当客户端从服务器取回数据时, 必须使用数据区块的长度来确定数据区块的
结束位置, 而不要依据数据区块末尾的“\r\n”, 即使它们固定存在于此.

2. 关键字 Key
存储在memcached中的数据通过键值来标识, 键值是一个文本字符串, 对于需要存取这项数据的客户端而言, 它必须是唯一的.
键值当前的长度限制设定为250字符(当然, 客户端通常不会用到这么长的键), 键值中不能使用制表符和其他空白字符(例如空格, 换行等).

3. 命令 Command
所有命令分为3种类型:
存储命令(有3项:’set’, ’add’, ’repalce’)指示服务器储存一些由键值标识的数据. 客户端发送一行命令, 后面跟着数据区块, 然后,
客户端等待接收服务器回传的命令行, 指示成功与否.

取回命令(只有一项：’get’)指示服务器返回与所给键值相符合的数据(一个请求中有一个或多个键值)客户端发送一行命令, 包括所有请求的键值,
服务器每找到一项内容, 都会发送回客户端一行关于这项内容的信息, 紧跟着是对应的数据区块. 直到服务器以一行“END”回应命令结束.

其他的命令都不能携带自由数据. 在这些命令中, 客户端发送一行命令, 然后等待(由命令所决定)一行回应, 或最终以一行“END”结束的多行命令.

一行命令固定以命令名称开始, 接着是以空格隔开的参数(如果有参数的话), 命令名称大小写敏感, 并且必须小写

4. 过期时间 Expiration Time
一些客户端发送给服务器的命令会包含一些时限(针对内容或客户端请求的操作), 这时, 时限的具体内容既可以是Unix时间戳(从1970年1月1日开始的秒钟数),
或当前时间开始的秒钟数, 对后者而言, 不能超过 60*60*24*30(30天), 如果超出, 服务器将会理解为Unix时间戳, 而不是从当前时间起的秒偏移.

5. 错误字串 Error String
每一个由客户端发送的命令，都可能收到来自服务器的错误字串回复, 这些错误字串会以三种形式出现：
"ERROR\r\n"
意味着客户端发送了不存在的命令名称

"CLIENT_ERROR <error>\r\n"
意味着输入的命令行里存在一些客户端错误, 例如输入未遵循协议. <error>部分是人类易于理解的错误解说

"SERVER_ERROR <error>\r\n"
意味着一些服务器错误, 导致命令无法执行. <error>部分是人类易于理解的错误解说, 
在一些严重的情形下(通常应该不会遇到), 服务器将在发送这行错误后关闭连接, 这是服务器主动关闭连接的唯一情况

6. 存储命令 Storage Command (set, add ,replace)
客户端会发送一行像这样的命令
<command name> <key> <flags> <exptime> <bytes>\r\n
<command name> 是set, add, 或者repalce
  set 意思是 “储存此数据”
  add 意思是 “储存此数据, 只在服务器*未*保留此键值的数据时”
  replace意思是 “储存此数据, 只在服务器*曾*保留此键值的数据时”

<key> 是接下来的客户端所要求储存的数据的键值

<flags> 是在取回内容时, 与数据和发送块一同保存服务器上的任意16位无符号整形(用十进制来书写), 客户端可以用它作
为“位域”来存储一些特定的信息；它对服务器是不透明的.

<exptime> 是终止时间, 如果为0, 该项永不过期(虽然它可能被删除, 以便为其他缓存项目腾出位置). 如果非0(Unix
时间戳或当前时刻的秒偏移), 到达终止时间后, 客户端无法再获得这项内容.
<bytes> 是随后的数据区块的字节长度, 不包括用于分野的“\r\n”, 它可以是0(这时后面跟随一个空的数据区块).

在这一行以后, 客户端发送数据区块:
<data block>\r\n
<data block> 是大段的8位数据, 其长度由前面的命令行中的<bytes>指定.

发送命令行和数据区块以后, 客户端等待回复, 可能的回复如下:
"STORED\r\n"
表明成功
"NOT_STORED\r\n"
表明数据没有被存储, 但不是因为发生错误, 这通常意味着add或replace命令的条件不成立,
或者, 项目已经位列删除队列(参考后文的“delete”命令).

7. 读取命令 Retrieval Command
get <key>*\r\n
<key>*表示一个或多个键值, 由空格隔开的字串
这行命令以后, 客户端的等待0个或多个项目, 每项都会收到一行文本, 然后跟着数据区块.
所有项目传送完毕后, 服务器发送以下字串
"END\r\n"
来指示回应完毕

服务器用以下形式发送每项内容
VALUE <key> <flags> <bytes>\r\n
<data block>\r\n
<key> 是所发送的键名
<flags> 是存储命令所设置的记号	
<bytes> 是随后数据块的长度, *不包括* 它的界定符“\r\n”
<data block> 是发送的数据
如果在取回请求中发送了一些键名, 而服务器没有送回项目列表,
这意味着服务器没这些键名(可能因为它们从未被存储, 或者为给其他内容腾出空间而被删除, 或者到期,
或者被已客户端删除).

8. 删除命令 Delete Command
命令“delete”允许从外部删除内容
delete <key> <time>\r\n
<key> 是客户端希望服务器删除的内容的键名
<time> 是一个单位为秒的时间(或代表直到某一刻的Unix时间), 在该时间内服务器会拒绝对于此键名
的“add”和“replace”命令, 此时内容被放入delete队列, 无法再通过“get”得到该内容, 也无法使用
“add”和“replace”命令(但是“set”命令可用), 直到指定时间, 这些内容被最终从服务器的内存中彻底清除.

<time>参数是可选的, 缺省为0(表示内容会立刻清除, 并且随后的存储命令均可用).

此命令有一行回应：
"DELETED\r\n"
表示执行成功
"NOT_FOUND\r\n"
表示没有找到这项内容

参考随后的“flush_all”命令使所有内容无效

9. 增加/减少 Increment/Decrement
命令“incr”和“decr”被用来修改数据, 当一些内容需要替换, 增加或减少时, 这些数据必须是十进制的32位无符号整新.
如果不是, 则当作0来处理. 修改的内容必须存在, 当使用“incr”/“decr”命令修改不存在的内容时, 不会被当作0处理,
而是操作失败.

客户端发送命令行：
incr <key> <value>\r\n
或
decr <key> <value>\r\n

<key> 是客户端希望修改的内容的建名
<value> 是客户端要增加/减少的总数

回复为以下几种情形:
"NOT_FOUND\r\n"
指示该项内容的值, 不存在

<value>\r\n
<value>是增加/减少 

注意"decr"命令发生下溢：
如果客户端尝试减少的结果小于0时, 结果会是0. "incr"命令不会发生溢出
 
10. 统计 Statistics
命令"stats" 被用于查询服务器的运行状态和其他内部数据,
有两种格式.
不带参数的
stats\r\n
这会在随后输出各项状态, 设定值和文档, 另一种格式带有一些参数
stats <args>\r\n
通过<args>, 服务器传回各种内部数据.

11. 多种统计 General Purpose Statistics
在收到无参数的"stats"命令后, 服务器发送多行内容, 如下
STAT <name> <value>\r\n
服务器用以下一行来终止这个清单：
END\r\n
在每行状态中, <name> 是状态的名字, <value> 使状态的数据.

12. 其它命令 Other Command
“flush_all”命令有一个可选的数字参数, 它总是执行成功, 服务器会发送“OK\r\n”回应.
它的效果是使已经存在的项目立即失效(缺省), 或在指定的时间后, 此后执行取回命令, 将不会有任何内容返回
(除非重新存储同样的键名).
flush_all实际上没有立即释放项目所占用的内存, 而是在随后陆续有新的项目被储存时执行.
flush_all效果具体如下：
它导致所有更新时间早于flush_all所设定时间的项目, 在被执行取回命令时命令被忽略.

“version”命令没有参数：
version\r\n
在回应中，服务器发送：
"VERSION <version>\r\n"
<version> 是服务器的版本字串.

“quit”命令没有参数：
quit\r\n
接收此命令后, 服务器关闭连接. 不过, 客户端可以在不再需要时, 简单地关闭连接就行, 并不一定需要发送这个命令





