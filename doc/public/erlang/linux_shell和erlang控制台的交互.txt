介绍一种常用的Linux Shell和Erlang控制台交互的方式

1. 原理:
<1> erlang如何从命令行erl获取参数?
init:get_plain_arguments() -> [Arg]
   Arg = string()
init:get_argument(Flag) -> {ok, Arg} | error
   Flag = atom()
   Arg = [Values]
   Values = [string()]
Doc: Everything following -extra is considered plain arguments and can be 
retrieved using get_plain_arguments/0.

例如:
erl -key1 val1 -key2 val2-0 val2-1 -extra a b c d
init:get_plain_arguments() -> ["a","b","c","d"]
init:get_argument(key1) -> {ok,[["val1"]]}
init:get_argument(key2) -> {ok,[["val2-0","val2-1"]]}

<2> erl一些常用的参数:
-noinput: Ensures that the Erlang runtime system never tries to read any input
-detached: Starts the Erlang runtime system detached from the system console. 
           Useful for running daemons and backgrounds processes
-s: 例如:
    erl -s foo -s foo bar -s foo bar baz 1 2
    foo:start()
    foo:bar()
    foo:bar([baz, '1', '2']) %% 参数看作: atom()

<3> 如何重启, 停止一个application?
init:stop()
init:restart()

<4> 控制台命令:
a. 所以我们启动一个'后台程序', 通常用下面命令:
   erl -noinput -detached -sname myapp@localhost -s myapp start
b. 接入在后台运行的erlang程序进行调试, 用如下命令:
   erl -sname myappdebug@localhost -remsh myapp@localhost
c. 运行myapp_ctl的代码:
   erl -noinput -sname myappctl@localhost \
     -s myapp_ctl -extra myapp@localhost $@

   处理逻辑:
   在myapp_ctl:start()中会调用下面代码获取参数:
   init:get_plain_arguments() -> [SNode | Args]
   然后调用rpc:call(list_to_atom(SNode), Module, Fun, Args)来执行远程节点
   myapp@localhost的函数调用, 并把结果通过halt(State)返回.

2. 实现:
==================================================
$myappctl
#!/bin/sh

###########################
# Configuration
###########################

ERL=erl
HOST=localhost

###########################
# End of configuration
###########################


NAME=myapp
NODE=$NAME@$HOST

case "$1" in
  start)
	 $ERL -noinput -detached -sname $NODE \
           -s myapp start
	 sleep 2
	 $0 status
	 ;;
  debug)
         echo "Press any key to continue" 
         read foo 
         $ERL -sname myappdebug@$HOST -remsh $NODE
         ;;
      *)
         $ERL -noinput -sname myappctl@$HOST \
           -s myapp_ctl -extra $NODE $@
         ;;
esac

==================================================
$myapp_ctl.erl
-module(myapp_ctl).
% remote control of the server

-export([start/0, process/1]).

-define(STATUS_SUCCESS, 0).
-define(STATUS_ERROR,   1).
-define(STATUS_USAGE,   2).
-define(STATUS_BADRPC,  3).

start() ->
    case init:get_plain_arguments() of
	[SNode | Args] ->
	    Node = list_to_atom(SNode),
	    Status = case rpc:call(Node, ?MODULE, process, [Args]) of
			 {badrpc, Reason} ->
			     io:format("RPC failed on the node ~p: ~p~n", [Node, Reason]),
			     ?STATUS_BADRPC;
			 S ->
			     S
		     end,
	    halt(Status);
	_ ->
	    print_usage(),
	    halt(?STATUS_USAGE)
    end.

process(["status"]) ->
    {InternalStatus, ProvidedStatus} = init:get_status(),
    io:format("Node ~p is ~p. Status: ~p~n",
              [node(), InternalStatus, ProvidedStatus]),
    case lists:keysearch(myapp, 1, application:which_applications()) of
        false ->
            io:format("myapp is not running~n", []),
            ?STATUS_ERROR;
        {value,_Version} ->
            io:format("myapp is running~n", []),
            ?STATUS_SUCCESS
    end;

process(["stop"]) ->
    init:stop(),
    ?STATUS_SUCCESS;

process(["restart"]) ->
    init:restart(),
    ?STATUS_SUCCESS;

process(_) ->
    print_usage(),
    ?STATUS_ERROR.


print_usage() ->
    io:format(
      "Usage: myappctl command~n"
      "~n"
      "Available commands:~n"
      "  start~n"
      "  stop~n"
      "  restart~n"
      "  status~n"
      "  debug~n"
      "~n"
      "Example:~n"
      "  myappctl restart~n"
     ).


==================================================
$myapp.erl
-module(myapp).
-behaviour(application).

%% Application callbacks
-export([start/2, stop/1]).
-export([start/0, loop/0]).

start() ->
    application:start(myapp).

start(normal, _StartArgs) ->
    case proc_lib:spawn_link(?MODULE, loop, []) of
	Pid -> 
	    {ok, Pid}
    end.

stop(_State) ->
    ok.

loop() ->
    timer:sleep(1000 * 5),
    io:format("myapp is running...~n", []),
    loop().

==================================================
$myapp.app
{application, myapp,
  [{description,
    "myapp description"},
   {vsn,          "1.0.0"},
   {modules,      [myapp]},
   {registered,   []},
   {applications, [kernel, stdlib]},
   {mod, {myapp,[]}}]}.
