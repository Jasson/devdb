Erlang的类型系统和静态分析

1. 背景:
类型标注系统可以帮助我们进行"静态检测".
Erlang有一套自己的类型标注系统, 不仅用来生成文档, 更重要的是可以据此对源码进行静态分析, 
通过程序来排除一些低级的和隐藏的错误.

在R13中, 将此前文档级的@spec, @type标注升级为语言级的 -spec, -type标注. 这样我们就可以
通过type和spec来自定数据类型以及函数原型, 通过这些信息, 我们对函数及调用进行"静态检测".

2. 类型标注系统的意义:
<1> 定义各种自定义数据类型
<2> 定义函数的参数及返回值
<3> dialyzer 进行代码静态分析
<4> edoc利用这些信息生成文档

3. 规范:
<1> 理解合集 
数据类型由"基本数据类型"及其他"自定义数据类型"组成, 其范围为对应数据类型的"合集"
例如(理解合集): 
atom() | integer()
与
atom() | 'bar' | integer() | 42
具有相同的含义.

<2> 层级关系:
各种类型之间具有一定的层级关系, 其中最顶层的any()可以代表任何Erlang类型, 而最底层
的none()表示空的数据类型.

<3> '预定义'的类型及语法如下:
Type :: any()           %% 最顶层类型, 表示任意的Erlang term
     | none()           %% 最底层类型, 不包含任何term
     | pid()
     | port()
     | ref()
     | []               %% nil
     | Atom
     | Binary
     | float()
     | Fun
     | Integer
     | List
     | Tuple
     | Union
     | UserDefined      %% described in Section 2

Union :: Type1 | Type2

Atom :: atom()
     | Erlang_Atom      %% 'foo', 'bar', ...

Binary :: binary()                        %% <<_:_ * 8>>
       | <<>>
       | <<_:Erlang_Integer>>            %% Base size
       | <<_:_*Erlang_Integer>>          %% Unit size
       | <<_:Erlang_Integer, _:_*Erlang_Integer>>

Fun :: fun()                             %% 任意函数
    | fun((...) -> Type)                 %% 任意arity, 只定义返回类型
    | fun(() -> Type)
    | fun((TList) -> Type)

Integer :: integer()
        | Erlang_Integer                 %% ..., -1, 0, 1, ... 42 ...
        | Erlang_Integer..Erlang_Integer %% 定义一个整数区间

List :: list(Type)                       %% 格式规范的list (以[]结尾)
     | improper_list(Type1, Type2)       %% Type1=contents, Type2=termination
     | maybe_improper_list(Type1, Type2) %% Type1 and Type2 as above

Tuple :: tuple()                          %% 表示包含任意元素的tuple
      | {}
      | {TList}

TList :: Type
      | Type, TList

由于lists经常使用, 我们可以将list(T)简写为[T], 而[T, ...]表示一个非空的元素类型为T的规范列表. 两者的区别是[T]可能为空, 
而[T, ...]至少包含一个元素.
'_' 可以用来表示任意类型.
请注意, list()表示任意类型的list, 其等同于[_]或[any()], 而 [], 仅仅表示一个单独的类型即空列表.

为了方便, 下面是一个内建类型列表:
---------------------------------------------
Built-in type	         Stands for
term()	                 any()
bool()	                 'false' | 'true'
byte()	                 0..255
char()	                 0..16#10ffff
non_neg_integer()	 0..
pos_integer()	         1..
neg_integer()	         ..-1
number()	         integer() | float()
list()	                 [any()]
maybe_improper_list()	 maybe_improper_list(any(), any())
maybe_improper_list(T)	 maybe_improper_list(T, any())
string()	         [char()]
nonempty_string()	 [char(),...]
iolist()	         maybe_improper_list(
                             char() | binary() | iolist(), binary() | [])
module()	         atom()
mfa()	                 {atom(),atom(),byte()}
node()	                 atom()
timeout()	         'infinity' | non_neg_integer()
no_return()	         none()
---------------------------------------------
类型定义不可重名, 编译器可以进行检测.
注意: 还存在一些其他lists相关的内建类型, 但是因为其名字较长, 我们很少使用:
nonempty_maybe_improper_list(Type) :: nonempty_maybe_improper_list(Type, any())
nonempty_maybe_improper_list() :: nonempty_maybe_improper_list(any())
我们也可以使用record标记法来表示数据类型:
Record :: #Erlang_Atom{}
        | #Erlang_Atom{Fields}
当前R13B中, 已经支持record定义中的类型说明

<4> 自定义类型:
通过前一章节的介绍, 我们知道基本的类型语法为"一个atom紧随一对圆括号", 如果我们想自定义一个新类型, 需要使用'type'关键字:
-type my_type() :: Type.
my_type为我们自定义的type名称, 其必须为atom.
Type为先前章节介绍的各种类型, 其可以为内建类型定义, 也可以为可见的(已经定义的)自定义数据类型. 否则会编译时保错.

<5> 自定义类型的参数化:
类型定义也可以参数化, 我们可以在括号中包含类型, 如同Erlang中变量定义, 这个参数必须以大写字母开头, 一个简单的例子:
-type orddict(Key, Val) :: [{Key, Val}].

<6> 在record中使用类型声明:
们可以指定record中字段的类型, 语法如下:
-record(rec, {field1 :: Type1, field2, field3 :: Type3}).

如果字段没有指明类型声明, 那么默认为 any(). 比如, 上面的record定义与此相同:
-record(rec, {field1 :: Type1, field2 :: any(), field3 :: Type3}).

如果我们在定义record的时候, "指明了初始值", 类型声明必须位于初始值之后:
-record(rec, {field1 = [] :: Type1, field2, field3 = 42 :: Type3}).

如果初始值类型与字段的类型声明不一致, 会产生一个编译期错误. filed的默认值为'undefined',
因此下面的两个个record定义效果相同:
-record(rec, {f1 = 42 :: integer(),
                f2      :: float(),
                f3      :: 'a' | 'b').

-record(rec, {f1 = 42 :: integer(),
                f2      :: 'undefined' | float(),
                f3      :: 'undefined' | 'a' | 'b').
所以, 推荐您在定义record时, 指明初始值.

小技巧:)
record定义后, 我们可以作为一个类型来使用, 其用法如下:
#rec{}
在使用recored类型时, 我们也可以重新指定某个field的类型:
#rec{some_field :: Type}
没有指明的filed, 类型与record定义时指明的类型相同.

<7> 函数规范定义:
函数规范可以通过新引入的关键字'spec'来定义(摒弃了旧的@spec声明)其语法如下:

-spec Module:Function(ArgType1, ..., ArgTypeN) -> ReturnType.
函数的参数数目必须与函数规范定义相同, 否则编译出错.

在同一个module内部, 可以简化为:
-spec Function(ArgType1, ..., ArgTypeN) -> ReturnType.
同时, 为了便于我们生成文档, 我们可以指明参数的名称:

-spec Function(ArgName1 :: Type1, ..., ArgNameN :: TypeN) -> RT.

注意 - 声明的'重载':
函数的spec声明可以重载, 通过';'来实现:
-spec foo(pos_integer()) -> pos_integer()
           ; (integer()) -> integer().

我们可以通过spec指明函数的输入和输出的某些关系:
-spec id(X) -> X.


4. 使用dialyzer进行静态分析:
<1> 生成PLT(Persistent Lookup Table)
为了分析我们的app或者module, 我们可以生成一个plt文件, 其目的是为了加速我们的代码分析过程,
plt内部很多类型及函数信息.

首先我们生成一个常用的plt文件, 其包含了以下lib：erts, kernel, stdlib, mnesia, crypto,
sasl, 各个lib因为erlang版本不同会有所差别, 我当前使用R13B03(erl 5.7.4):

a. cd /usr/lib/erlang/bin
b. ./dialyzer --build_plt -r /usr/lib/erlang/lib/erts-5.7.4/ebin \
                             /usr/lib/erlang/lib/kernel-2.13.4/ebin \
                             /usr/lib/erlang/lib/stdlib-1.16.4/ebin \
                             /usr/lib/erlang/lib/mnesia-4.4.12/ebin \
                             /usr/lib/erlang/lib/crypto-1.6.3/ebin \
                             /usr/lib/erlang/lib/sasl-2.1.8/ebin
注意: 
编译erlang OTP的时候必须使用+debug_info参数, 否则这一步无法获得类型信息, 会出现下面错误
ialyzer: Could not get abstract code for file: /usr/lib/erlang/li
b/crypto-1.6.3/ebin/crypto.beam (please recompile it with +debug_info)

经过十几分钟的的等待, 生成了一个~/.dialyzer_plt文件, 在生成plt时, 可以通过--output_plt
指定生成的plt的名称.
c. 从plt中增加/删除文件:
我们也可以随时通过: 
dialyzer --add_to_plt --plt ~/.dialyzer_plt -c path_to_app 添加应用到既有plt中.
也可以通过: 
dialyzer --remove_from_plt --plt ~/.dialyzer_plt -c path_to_app 从已有plt中删除某个应用.

例如:
% 从plt中去处crypto应用
dialyzer --remove_from_plt --plt ~/.dialyzer_plt -c /usr/lib/erlang/lib/crypto-1.6.3/ebin

% 向plt中添加crypto应用
dialyzer --add_to_plt --plt ~/.dialyzer_plt -c /usr/lib/erlang/lib/crypto-1.6.3/ebin

<2> 进行静态分析:
(要注意: 必须使用+debug_info的编译选项)
dialyzer -r /home/user/erlangcode/eproj1



