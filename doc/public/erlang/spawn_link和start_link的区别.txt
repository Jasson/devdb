比较两个API: spawn_link/3和start_link/3的区别:


1. API文档说明
a. proc_lib:spawn_link(Module, Function, Args) -> pid()
文档:
Returns the pid of a new process started by the application of Module:Function 
to Args. A link is created between the calling process and the new process, 
atomically.

b. proc_lib:start_link(Module, Function, Args) -> Ret
Ret = term() | {error, Reason}
文档:
Starts a new process synchronously. Spawns the process and waits for it to 
start. When the process has started, it must call init_ack(Parent,Ret) or 
init_ack(Ret), where Parent is the process that evaluates this function. 
At this time, Ret is returned.

If the start_link/3,4 function is used and the process crashes before it 
has called init_ack/1,2, {error, Reason} is returned if the calling process 
traps exits.

If Time is specified as an integer, this function waits for Time milliseconds 
for the new process to call init_ack, or {error, timeout} is returned, and 
the process is killed.

2. 区别
<1> spawn_link调用之后马上返回一个子进程的pid, 这个进程会放在system scheduler queue中
稍候运行, 可以理解这是一种'异步'的方式启动一个子进程.

<2> start_link/3是一种'同步'的方式启动一个子进程, 只有当子进程调用init_ack/2的时候, 这个
调用才会返回, 否则会一直hang在调用处.

<3> start_link/4有timeout的机制: start_link(Module, Function, Args, Time) -> Ret
子进程在Time时间内仍然没有调用init_ack/2, 则返回{error, timeout}错误.

<4> spawn_link的返回值是一个pid, start_link的返回值取决于子进程, 例如子进程调用:
init_ack(Parent, Ret)则返回Ret.

3. 测试例子:
-module(test).
-export([test_spawn_link/1, test_start_link/1, loop1/1, loop2/1]).

test_spawn_link(Fun) ->
    proc_lib:spawn_link(?MODULE, Fun, [self()]),
    io:format("spawn_link complete~n", []).

test_start_link(Fun) ->
    proc_lib:start_link(?MODULE, Fun, [self()]),
    io:format("start_link complete~n", []).

loop1(Parent) ->
    proc_lib:init_ack(Parent, ok),
    receive
	Msg ->
	    io:format("received: ~p~n", [Msg])
    end.

loop2(_Parent) ->
    receive
	Msg ->
	    io:format("received: ~p~n", [Msg])
    end.

测试:
test:test_spawn_link(loop1).
spawn_link complete
ok
test:test_spawn_link(loop2).
spawn_link complete
ok
test:test_start_link(loop1).
start_link complete
ok
test:test_start_link(loop2). %% 会一直hang在这个位置, 不会返回, 因为loop2
                             %% 没有调用init_ack/2

