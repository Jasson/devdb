$ejabberd_loglevel.erl
$ejabberd_logger_h.erl
$dynamic_compile.erl

主要分析ejabberd的log机制

1. logger模块
ejabberd_loglevel  - 一个动态的log模块
ejabberd_logger_h  - 一个error_logger的event handler模块.

<1> a. 该模块依赖于dynamic_compile模块.
    b. 在使用项目初始化的时候应该先安装ejabberd_logger_h.
       error_logger:add_report_handler(ejabberd_logger_h, LogPath)

<2> log分为0-5一共6个等级
    等级数字越大, 记录的内容越详细, 如5是debug模式, 记录的日志最详细

<3> ejabberd_loglevel
    ejabberd_loglevel模块只有两个APIs:
    set(Level) -> 设置当前的loglevel, 每次调用这个函数, 都会根据level
                  动态的生成一个ejabberd_logger模块, 也就是ejabberd_logger
                  模块是动态生成的, 所以我们在使用它以前, 至少要调用一次set/1函数.
    get()      -> 返回当前的loglevel

    ejabberd.hrl中提供了一些宏来方便使用ejabberd_logger模块, 例如:
    %% Logging mechanism 
    -define(DEBUG(Format, Args), 
                ejabberd_logger:debug_msg(?MODULE,?LINE,Format, Args)). 
    -define(INFO_MSG(Format, Args), 
                ejabberd_logger:info_msg(?MODULE,?LINE,Format, Args)).
    ...

<4> ejabberd_logger_h 
    ejabberd_logger_h是实现的一个新error_logger的event handler, 实现了gen_event
    callback的模块.
    error_logger的默认行为是把错误日志输出到stdout,我们可以使用
    error_logger:add_report_handler(ejabberd_logger_h, LogPath)的方式来为
    error_logger安装一个新的事件处理器, 这样的话, 错误日志会同步输出到LogPath指定的文件
    里面.

    使用方式:
    error_logger:error_msg(“this is error msg”).  %% 日志只会记录到stdout
    %% 安装新error_logger事件处理handler
    error_logger:add_report_handler(ejabberd_logger_h, LogPath). 
    %% 日志会输出到记录到log
    error_logger:error_msg(“this is error msg – new”). 

    注意:
    只能调用一次add_report_handler/2, 如果调用多次, 一次调用会记录多条记录.
    删除event handler使用error_logger:delete_report_handler(ejabberd_logger_h).

2. 测试代码:
-module(log_test).
-export([run/0, scenario1/0, scenario2/0]).

-define(LOG_PATH, "test.log").

%%
%% <1> ejabberd的logger模块依赖于dynamic_compile模块
%% <2> 在使用ejabberd_logger模块前必须调用, ejabber_loglevel:set/1函数.
%%     因为ejabber_logger模块是动态生成的, 当我们调用ejabberd_loglevel:set/1
%%     设置level的时候, 会动态生成一个ejabberd_logger模块. 当再次调用set/1来修改
%%     level的时候, 会生成一个新的ejabberd_logger模块.
%% 

run() ->
    scenario1(),
    scenario2().


%% 使用ejabberd_logger
scenario1() ->
    %% scenario - 1
    ejabberd_loglevel:set(3), %% warning, debug和info将不会被输出
    ejabberd_logger:debug_msg(?MODULE, ?LINE, "this is ~p msg~n", ["debug"]),
    ejabberd_logger:info_msg(?MODULE, ?LINE, "this is ~p msg~n", ["info"]),
    ejabberd_logger:warning_msg(?MODULE, ?LINE, "this is ~p msg~n", ["warning"]),
    ejabberd_logger:error_msg(?MODULE, ?LINE, "this is ~p msg~n", ["error"]),
    ejabberd_logger:critical_msg(?MODULE, ?LINE, "this is ~p msg~n", ["critical"]),

    %% scenario - 2
    ejabberd_loglevel:set(5), %% debug, 所有的信息都会输出
    ejabberd_logger:debug_msg(?MODULE, ?LINE, "this is ~p msg~n", ["debug"]),
    ejabberd_logger:info_msg(?MODULE, ?LINE, "this is ~p msg~n", ["info"]),
    ejabberd_logger:warning_msg(?MODULE, ?LINE, "this is ~p msg~n", ["warning"]),
    ejabberd_logger:error_msg(?MODULE, ?LINE, "this is ~p msg~n", ["error"]),
    ejabberd_logger:critical_msg(?MODULE, ?LINE, "this is ~p msg~n", ["critical"]).

%% 注意:
%% 如果我们不调用delete_report_handler/1, 在下次运行demo2/0的时候,
%% ejabberd_logger_h会添加两次. 所以一次调用会记录2条信息.
scenario2() ->
    error_logger:add_report_handler(ejabberd_logger_h, ?LOG_PATH),
    error_logger:info_msg("this is a test msg"),
    error_logger:delete_report_handler(ejabberd_logger_h).
