$expat_erl.c
$xml.erl
$xml_stream.erl


1. xml模块
<1> 该模块依赖C的Port driver: expat_erl.so 这个模块依赖libexpat1-dev包.

<2> 内部使用的数据结构,用tuple来表示xml文档结构:
    三类数据: {xmlelement, Name:string(), AttrList, ChildList}
             {xmlcdata, Cdata:binary()}
             {AttrKey:string(), AttrVal:string()}
   例如:
   <stream></stream>  ->
     {xmlelement, “stream”, [], []}
   <stream key1='val1'></stream> ->
     {xmlelement, “stream”, [{“key1”, “val1”}], []}
   <stream key1='val1'><div>data</div></stream> ->
     {xmlelement,"stream", [{"key1","val1"}], 
                           [{xmlelement,"div",[],[{xmlcdata,<<"data">>}]}]}

2. 两种解析XML的形式:
<1> 同步: (一次性解析整个XML文档, 然后返回结果)
    如果要单独的使用该模块, 必须手动的加载expat_erl.so库.
    erl_ddll:load_driver(".", "expat_erl"). %% 先手动加载库
    xml_stream:parse_element("<stream>data1<div key='val'>data2</div></stream>").

    返回的结果:
    {xmlelement,"stream",[], 
            [{xmlcdata,<<"data1">>}, 
             {xmlelement,"div", 
                         [{"key","val"}], 
                         [{xmlcdata,<<"data2">>}]}]} 

<2> 异步:
    异步的方式处理XML:
    a. 实现一个gen_fsm模块, 在这个模块中处理XML
       这个模块应该处理下面的事件, 这些事件会自动发送到该模块.
       {xmlstreamstart, Name, Attrs}
       {xmlstreamend, EndName}
       {xmlstreamelement, NewEl}
       {xmlstreamerror, Err}
    b. 启动gen_fsm模块
       {ok, FsmPid} = gen_fsm:start_link(FsmMod, Args, Opts)  ---> FsmMod:init() 返回-> {ok,StateName,StateData}
    c. 注册FsmPid到xml_stream, 这样处理xml的事件结果就会发送到FsmPid对应的进程处理.
       S0 = xml_stream:new(FsmPid)
    d. 解析XML Data, 解析的结果会根据a中的四个事件发送到FsmPid.
       S1 = xml_stream:parse(S0, Str),
       S2 = xml_stream:parse(S1, Str),
       ....       

3. 例子:
a. 同步解析xml的例子:
-module(xml_sync_test).
-export([init/0, run/0]).


init() ->
    erl_ddll:load_driver(".", "expat_erl").

run() ->
    xml_stream:parse_element(xml_doc()).

%% Internal APIs:
xml_doc() ->
    "<stream><testtag attr1='val1'>data</testtag><div><span attr2='val2'>test</span></div></stream>".

b. 异步解析xml的例子:
-module(xml_async_test).
-export([start_link/0, run/0, init/1, xml_loop/2]).

-define(XML_LOOP_PID, xmllooppid).    

%%
%% <stream>
%%   <div attr1='val1'>div-data</div>
%%   <br>br-data</br>
%%   stream-data
%% </stream>
%%
%% 注意:
%% root节点下的cdata会忽略, 子节点的不会:
%% stream-data会忽略, 这符合xmpp协议的要求,
%% <stream>元素下面不会直接传输cdata.

%% 返回的结果:
%% xmlstreamstart# "stream":[]
%% xmlstreamelement# {xmlelement,"div",
%%                              [{"attr1","val1"}],
%%                              [{xmlcdata,<<"div-data">>}]}
%% xmlstreamelement# {xmlelement,"br",[],[{xmlcdata,<<"br-data">>}]}
%% xmlstreamend# "stream"

%% 逻辑
%% -record(xml_stream_state, {callback_pid, port, stack, size, maxsize}).
%% a. 我们自己实现一个gen_fsm, 在其中处理4个XML事件
%% b. State = xml_stream:new(Pid)               %% XML处理结果会发送给这个Pid进程, S
%%                                                 tate中会记录这个Pid, 以及打开的port
%% c. StateNew = xml_stream:parse(State, Str) %% 解析XML数据
%%    ...

run() ->
    S1 = start_link(),
    S2 = xml_stream:parse(S1, "<stream><div attr1='val1'>"),
    S3 = xml_stream:parse(S2, "div-data</div><br>br-d"),
    xml_stream:parse(S3, "ata</br>stream-data</stream>").

start_link() ->
    erl_ddll:load_driver(".", "expat_erl"),
    {ok, Pid} = gen_fsm:start_link(?MODULE, [], []), %% 新建一个gen_fsm进程来接收处理后的xml数据.
    XmlState = xml_stream:new(Pid),                  %% 核心, 关联gen_fsm进程, 这样xml_stream:parse/2的数据
                                                     %% 就会发送到这个Pid
    XmlState.
    

init(_Args) ->
    {ok, xml_loop, []}.            %% {ok, StateName, StateData}

xml_loop({xmlstreamstart, Name, Attrs}, []) ->
    io:format("xmlstreamstart# ~p:~p~n", [Name, Attrs]),
    {next_state, xml_loop, []};    %% {next_state,NextStateName,NewStateData}
xml_loop({xmlstreamend, EndName}, []) ->
    io:format("xmlstreamend# ~p~n", [EndName]),
    {next_state, xml_loop, []};
xml_loop({xmlstreamelement, NewEl}, []) ->
    io:format("xmlstreamelement# ~p~n", [NewEl]),
    {next_state, xml_loop, []};
xml_loop({xmlstreamerror, Err}, []) ->
    io:format("xmlstreamerror# ~p~n", [Err]),
    {next_state, xml_loop, []}.
